# File produced by Kranc


if (other_timelevels == 1)
{
  STORAGE: DenF_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: DenLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: DenRight_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: EnF_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: EnLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: EnRight_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: p_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: pLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: pRight_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: rho_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: rhoLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: rhoRight_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: SF_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: SLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: SRight_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: v_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: vLeft_group[1]
}

if (other_timelevels == 1)
{
  STORAGE: vRight_group[1]
}

if (timelevels == 1)
{
  STORAGE: Den_group[1]
}
if (timelevels == 2)
{
  STORAGE: Den_group[2]
}
if (timelevels == 3)
{
  STORAGE: Den_group[3]
}

if (timelevels == 1)
{
  STORAGE: En_group[1]
}
if (timelevels == 2)
{
  STORAGE: En_group[2]
}
if (timelevels == 3)
{
  STORAGE: En_group[3]
}

if (timelevels == 1)
{
  STORAGE: S_group[1]
}
if (timelevels == 2)
{
  STORAGE: S_group[2]
}
if (timelevels == 3)
{
  STORAGE: S_group[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: Den_grouprhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: Den_grouprhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: Den_grouprhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: En_grouprhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: En_grouprhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: En_grouprhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: S_grouprhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: S_grouprhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: S_grouprhs[3]
}

schedule Euler_Startup at STARTUP
{
  LANG: C
  OPTIONS: meta
} "create banner"

schedule Euler_RegisterSymmetries in SymmetryRegister
{
  LANG: C
  OPTIONS: meta
} "register symmetries"


if (CCTK_EQUALS(initial_data, "shock"))
{
  schedule euler_initial_shock at CCTK_INITIAL as euler_initial
  {
    LANG: C
    READS:    grid::x
    WRITES:   Euler::p
    WRITES:   Euler::rho
    WRITES:   Euler::v1
    WRITES:   Euler::v2
    WRITES:   Euler::v3
  } "euler_initial_shock"
}

schedule euler_primitives in MoL_PostStep after Euler_ApplyBCs
{
  LANG: C
  READS:    Euler::Den
  READS:    Euler::En
  READS:    Euler::S1
  READS:    Euler::S2
  READS:    Euler::S3
  WRITES:   Euler::p
  WRITES:   Euler::rho
  WRITES:   Euler::v1
  WRITES:   Euler::v2
  WRITES:   Euler::v3
} "euler_primitives"

schedule euler_conserved at INITIAL after euler_initial
{
  LANG: C
  READS:    Euler::p
  READS:    Euler::rho
  READS:    Euler::v1
  READS:    Euler::v2
  READS:    Euler::v3
  WRITES:   Euler::Den
  WRITES:   Euler::En
  WRITES:   Euler::S1
  WRITES:   Euler::S2
  WRITES:   Euler::S3
} "euler_conserved"

schedule euler_zero_rhs in MoL_CalcRHS
{
  LANG: C
  WRITES:   Euler::Denrhs
  WRITES:   Euler::Enrhs
  WRITES:   Euler::S1rhs
  WRITES:   Euler::S2rhs
  WRITES:   Euler::S3rhs
} "euler_zero_rhs"

schedule group euler_reconstruct_1_group in MoL_CalcRHS after euler_zero_rhs
{
  # no language specified
} "euler_reconstruct_1"

schedule euler_reconstruct_1 in euler_reconstruct_1_group
{
  LANG: C
  READS:    Euler::p
  READS:    Euler::rho
  READS:    Euler::v1
  READS:    Euler::v2
  READS:    Euler::v3
  WRITES:   Euler::pLeft
  WRITES:   Euler::pRight
  WRITES:   Euler::rhoLeft
  WRITES:   Euler::rhoRight
  WRITES:   Euler::vLeft1
  WRITES:   Euler::vLeft2
  WRITES:   Euler::vLeft3
  WRITES:   Euler::vRight1
  WRITES:   Euler::vRight2
  WRITES:   Euler::vRight3
} "euler_reconstruct_1"

schedule euler_reconstruct_1_SelectBCs in euler_reconstruct_1_bc_group
{
  LANG: C
  OPTIONS: level
  SYNC: pLeft_group
  SYNC: pRight_group
  SYNC: rhoLeft_group
  SYNC: rhoRight_group
  SYNC: vLeft_group
  SYNC: vRight_group
} "euler_reconstruct_1_SelectBCs"

schedule group ApplyBCs as euler_reconstruct_1_ApplyBCs in euler_reconstruct_1_bc_group after euler_reconstruct_1_SelectBCs
{
  # no language specified
} "Apply BCs for groups set in euler_reconstruct_1"

schedule group euler_reconstruct_1_bc_group in euler_reconstruct_1_group after euler_reconstruct_1
{
  # no language specified
} "euler_reconstruct_1"

schedule group euler_reconstruct_1_bc_group in MoL_PseudoEvolutionBoundaries after MoL_PostStep
{
  # no language specified
} "euler_reconstruct_1"

schedule euler_conserved_flux_1 in MoL_CalcRHS after euler_reconstruct_1
{
  LANG: C
  READS:    Euler::pLeft
  READS:    Euler::pRight
  READS:    Euler::rhoLeft
  READS:    Euler::rhoRight
  READS:    Euler::vLeft1
  READS:    Euler::vLeft2
  READS:    Euler::vLeft3
  READS:    Euler::vRight1
  READS:    Euler::vRight2
  READS:    Euler::vRight3
  WRITES:   Euler::DenLeft
  WRITES:   Euler::DenRight
  WRITES:   Euler::EnLeft
  WRITES:   Euler::EnRight
  WRITES:   Euler::SLeft1
  WRITES:   Euler::SLeft2
  WRITES:   Euler::SLeft3
  WRITES:   Euler::SRight1
  WRITES:   Euler::SRight2
  WRITES:   Euler::SRight3
} "euler_conserved_flux_1"

schedule group euler_flux_1_group in MoL_CalcRHS after euler_conserved_flux_1
{
  # no language specified
} "euler_flux_1"

schedule euler_flux_1 in euler_flux_1_group
{
  LANG: C
  READS:    Euler::DenLeft
  READS:    Euler::DenRight
  READS:    Euler::EnLeft
  READS:    Euler::EnRight
  READS:    Euler::pLeft
  READS:    Euler::pRight
  READS:    Euler::rhoLeft
  READS:    Euler::rhoRight
  READS:    Euler::SLeft1
  READS:    Euler::SLeft2
  READS:    Euler::SLeft3
  READS:    Euler::SRight1
  READS:    Euler::SRight2
  READS:    Euler::SRight3
  READS:    Euler::vLeft1
  READS:    Euler::vLeft2
  READS:    Euler::vLeft3
  READS:    Euler::vRight1
  READS:    Euler::vRight2
  READS:    Euler::vRight3
  WRITES:   Euler::DenF
  WRITES:   Euler::EnF
  WRITES:   Euler::SF1
  WRITES:   Euler::SF2
  WRITES:   Euler::SF3
} "euler_flux_1"

schedule euler_flux_1_SelectBCs in euler_flux_1_bc_group
{
  LANG: C
  OPTIONS: level
  SYNC: DenF_group
  SYNC: EnF_group
  SYNC: SF_group
} "euler_flux_1_SelectBCs"

schedule group ApplyBCs as euler_flux_1_ApplyBCs in euler_flux_1_bc_group after euler_flux_1_SelectBCs
{
  # no language specified
} "Apply BCs for groups set in euler_flux_1"

schedule group euler_flux_1_bc_group in euler_flux_1_group after euler_flux_1
{
  # no language specified
} "euler_flux_1"

schedule group euler_flux_1_bc_group in MoL_PseudoEvolutionBoundaries after MoL_PostStep
{
  # no language specified
} "euler_flux_1"

schedule euler_rhs_1 in MoL_CalcRHS after euler_flux_1
{
  LANG: C
  READS:    Euler::DenF
  READS:    Euler::Denrhs
  READS:    Euler::EnF
  READS:    Euler::Enrhs
  READS:    Euler::S1rhs
  READS:    Euler::S2rhs
  READS:    Euler::S3rhs
  READS:    Euler::SF1
  READS:    Euler::SF2
  READS:    Euler::SF3
  WRITES:   Euler::Denrhs
  WRITES:   Euler::Enrhs
  WRITES:   Euler::S1rhs
  WRITES:   Euler::S2rhs
  WRITES:   Euler::S3rhs
} "euler_rhs_1"

schedule Euler_SelectBoundConds in MoL_PostStep
{
  LANG: C
  OPTIONS: level
  SYNC: Den_group
  SYNC: En_group
  SYNC: S_group
} "select boundary conditions"

schedule Euler_CheckBoundaries at BASEGRID
{
  LANG: C
  OPTIONS: meta
} "check boundaries treatment"

schedule Euler_RegisterVars in MoL_Register
{
  LANG: C
  OPTIONS: meta
} "Register Variables for MoL"

schedule group ApplyBCs as Euler_ApplyBCs in MoL_PostStep after Euler_SelectBoundConds
{
  # no language specified
} "Apply boundary conditions controlled by thorn Boundary"
